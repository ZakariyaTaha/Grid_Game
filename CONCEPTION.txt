Au niveau des acteurs, j’ai choisi de les modéliser en 4 grandes superclasses et quelques classes indépendantes :
1) Collectable qui constitue l’ensemble des classes représentant des objets collectables, qui sont Key et Apple. Key a pour particularité un attribut Logic qui me permettra par la suite de contrôler l’ouverture des portes.
2) Wearable qui constitue l’ensemble des classes représentant des objets que l’on peut porter : Helmet,Sword,Shield,Bow. C’est aussi l’ensemble des objets nécessaire pour combattre les monstres et sans lesquels le personnage quittera la partie s’il combat, ils ont ainsi comme attribut un Logic conditionnant l’issue du combat contre les deux boss comme on peut le voir dans Begin.
3) Switchable regroupant l’ensemble des classes représentant des objets qui peuvent passer d’un état à un autre : Lever qui switch entre gauche et droite, Torch qui s’allume, PressureSwitch qui est une sorte d’interrupteur et PressurePlate qui est une sorte d’interrupteur temporisé(5sec).
4) Mobs regroupant l’ensemble des types de monstres rencontrant au long des étapes, Mob1, Mob2 et Mob3. Chacun des 3 types possède deux attribut Logic, le premier qui conditionne son apparition (je peux parfois décider de ne le faire apparaitre que quand le personnage rempli une certaine condition comme par exemple avoir pris l’épée) et un deuxième attribut indiquant l’ensemble des conditions à remplir pour pouvoir le battre.
5) D’autres classes indépendantes : Door,SignalDoor qui est sa variable que l’on peut conditionner avec un attribut Logic, SignalRock qui peut apparaitre ou disparaitre si on remplit les conditions, NonPlayingCharacter qui représente le fantôme du jeu, Potion qui permet de le faire apparaitre, et enfin Victim qui a comme instance l’enfant qu’on cherche à sauver.

Comme extensions, j’ai programmé, en plus de l’énigme accessible à partir de la 4ème porte :
1) L’extension pause qui arrête le programme et affiche le texte « Pause » quand on clique sur la touche espace, puis le reprend de la même manière. J’ai réalisé cette pause en influant sur la méthode update d’Area, de sorte que si je clique sur la touche L, le programme ne peut plus update les acteurs ni effectuer leurs interactions, il peut en revanche les dessiner et indiquer qu’il est en état de pause.
2) L’extension animation : j’ai fait en sorte d’animer la torche avec un procédé assez simple. J’ai créé un attribut Boolean static, et dès que la torche est allumée la méthode draw l’incrémente tout en modifiant le Sprite pour chaque nombre modulo 2, ce qui donne deux Sprite qui se succèdent. Concernant l’EnigmePlayer c’est un peu plus compliqué vu que j’ai essayé de regrouper l’ensemble des cas possibles pour le dessin du Sprite en 1 seule instruction : j’ai créé un attribut Map et un attribut nommé step similaire à celui de torche. Dans la map j’ai associé chaque orientation au nombre correspondant à la colonne dans la « matrice des images » (0 pour DOWN ...) et à chaque move s’incrémente le step. Ainsi dans le constructeur du sprite, j’obtiens directement le nombre lié à l’orientation grâce à la Map, et le nombre de la ligne s’obtient grâce au step modulo 4, on aura ainsi 4 cas possibles pour chaque orientation, donc 16 en tout.
3) J’ai aussi inséré plusieurs Dialog dans mon énigme, notamment pour fournir les instructions nécessaires au joueur.
À part l’ensemble des méthodes ajoutés aux acteur, j’ai aussi ajouté une méthode isInGrind(x,y) à AreaBehavior qui test si un objet de coordonnées (x,y) appartient au tableau Cells.

Enfin, concernant les classes Enigme1 et Enigme2 que j’ai rajoutés comme extensions, elles ont plusieurs attributs, et cela pour une unique raison: permettre une gestion interne, c'est à dire pouvoir les modifier et les conditionner lors de mon update, sinon je n’aurais pas pu étant donné qu’ils auraient été invisibles en dehors de Begin ou ils auraient été déclarés.
